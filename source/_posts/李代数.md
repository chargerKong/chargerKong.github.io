---
title: SLAM之李代数
date: 2021-06-16 10:23:20
tags: math
---

## 李代数是什么？

对应于每一个李群，都有对应的一个李代数。譬如，有一个旋转矩阵$R_0\in SO(3)，SO(3)$为所有旋转矩阵组成的群。都有一个李代数，一个**三维向量**$\phi$与之对应。**李代数描述了李群在局部的性质**，这是因为R(t)通过在$t=0$处的泰勒展开而得到的李代数。

他们的关系为
$$
R=\exp(\phi \hat{})
$$

## 为什么要用李代数

在SLAM中，我们要估计一个相机的位置和姿态，此位姿是有$SO(3)$上的旋转矩阵或者$SE(3)$的变换矩阵所描述的，在估计的过程中，避免不了需要对旋转矩阵求导。根据求导的定义，需要进行加法。但是$SO(3)$没有加法，可以把问题转换为对应的李代数进行计算



## Sophus上的简单使用

在使用Sophus的时候，已知$R$，求$\phi$的时候，只需要求一个$log$就可以了。出来的直接是三维的李代数，无需在vee（反对称矩阵->三维向量的操作）

假设已经有了一个旋转矩阵，R 

```c++
// 建立一个李群SO(3)
//可以通过一个旋转矩阵得到
Sophus::SO3<double> SO3_R(R)；
//也可以通过一个四元数获得
Quanterniond q(R);
Sophus::SO3<double> SO3_q(q)；
// 从李群求李代数
Vector3d so3 = SO3_R.log();

// 从李代数求李群
Sophus::SO3<double> SO3_R2 = Sophus::SO3d::exp(so3);

//李群可以直接参与坐标变换运算
Vector3d after_rot = SO3_R * Vector3d{0, 0, 1};

//位姿的更新，通过两个李群相乘可以得到
//dx 为更新量李代数
Sophus::SO3d SO3_update = Sophus::SO3d::exp(dx) * SO3_R;

// 返回对应的矩阵
cout << SO3_update.matrix() << endl;
```





## 群

两个旋转相加就不再是旋转矩阵的，这样的话就不好使用导数。因此在估计的时候，我们需要借用李群，李代数



- 三维旋转矩阵构成了特殊正交群



一些例子

- 一般线性群$GL$.矩阵乘法群

- 特殊矩阵群$SO$
- 特殊欧式群$SE$。n维欧式变换



群结构保证了在群上的运算具有良好的性质



## 李群

- 具有连续性质的群
- 即是群也是流形（mainfold）:流行可以看做是高维空间低维的东西，就是高维度中的一小片
- 虽然都是SO(3)和SE(3)都是李群，但是没有加法，不好求极限



## 李代数

李代数和李群是一一对应的。事实上它是李群在单位元处的正切空间



假设R为随时间变化的函数。  



指数映射：exp(李代数^) = 李群



## 指数对应和对数映射

$$
\begin{equation}
\begin{split}
\exp(\boldsymbol{A})&=\exp(\phi\hat{})\\
&=\exp(\theta\boldsymbol{a}\hat{})\\
&=\cos\theta\boldsymbol{I}+(1-\cos\theta)\boldsymbol{a}\boldsymbol{a}^T+\
\sin\theta\boldsymbol{a}\hat{}

\end{split}
\end{equation}
$$

## 李代数求导

一般使用扰动模型求导，
$$
\frac{\partial(Rp)}{\partial\phi}=-(Rp)\hat{}
$$
