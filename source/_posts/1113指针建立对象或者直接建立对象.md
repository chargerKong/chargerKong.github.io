---
title: C++用new创建对象和不用new创建对象的区别解析
date: 2021-11-08 19:38:29
tags: c++
---

转载 https://blog.csdn.net/xie_star/article/details/37533559?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242.2

建立对象有几种方式

```
A b();
A* c = new A();
```

第一种是直接显示调用。

第二种是使用了指针，指针此对象。



那么时候什么时候使用指针的形式，什么时候使用非指针的形式，下面看一下区别

# 使用指针和非指针创建对象的区别

总结：

- 能用栈则用栈
- 但我们需要的内存很少，你又能确定你到底需要多少内存时，请用栈，直接创建对象。而当你需要在运行时才知道你到底需要多少内存时，请用指针，即堆。
- 栈的效率比堆要高得多。



细讲：

**这里面有几个问题：
**1.堆和栈最大可分配的内存的大小
2.堆和栈的内存管理方式
3.堆和栈的分配效率

首先针对第一个问题，一般来说对于一个进程栈的大小远远小于堆的大小，在linux中，你可以使用ulimit -s (单位kb)来查看一个进程栈的最大可分配大小，一般来说不超过8M，有的甚至不超过2M，不过这个可以设置，而对于堆你会发现，针对一个进程堆的最大可分配的大小在G的数量级上，不同系统可能不一样，比如32位系统最大不超过2G，而64为系统最大不超过4G，所以当你需要一个分配的大小的内存时，请用new，即用堆。

其次针对第二个问题，栈是系统数据结构，对于进程/线程是唯一的，它的分配与释放由操作系统来维护，不需要开发者来管理。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，不同的操作系统对栈都有一定的限制。 堆上的内存分配，亦称动态内存分配。程序在运行的期间用malloc申请的内存，这部分内存由程序员自己负责管理，其生存期由开发者决定：在何时分配，分配多少，并在何时用free来释放该内存。这是唯一可以由开发者参与管理的内存。使用的好坏直接决定系统的性能和稳定。

由上可知，但我们需要的内存很少，你又能确定你到底需要多少内存时，请用栈。而当你需要在运行时才知道你到底需要多少内存时，请用堆。

最后针对第三个问题，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率 比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在 堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会 分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

# 栈和堆的区别

from:https://blog.csdn.net/nianmaodu/article/details/105919114
从硬件上，堆和栈都是内存条上若干存储单元，并没有什么不同。 但是很多CPU对压栈出栈有指令上的支持，所以栈区分配/归还内存速度极快

**要点**：物理上相同，堆是系统抽象的。但是栈内存快：①有CPU指令上的支持，②CPU缓存使得访问局部变量变快。



# 如何查看类大小

```c++
#include <iostream>
class CBase
{
};

class CBase1 
{ 
int a; 
char p; 
}; 

class CBase2
{
    // CBase2(void); 
    virtual ~CBase2(void); 
    int   a; 
    char *p; 
};

class CBase3
{ 
public: 
CBase3(void); 
// virtual ~CBase3(void); 
 
virtual void test();
private: 
int b;
CBase1 a();
}; 

int main()
{
    // 类所占内存的大小主要是由成员变量（静态变量除外）决定的，成员函数（虚函数除外）是不计算在内的。

    std::cout << sizeof(CBase) << std::endl;  // 1字节
    std::cout << sizeof(CBase1) << std::endl; // 8字节
    std::cout << sizeof(CBase2) << std::endl; // 24字节, 有一个指向虚函数的指针16字节
    std::cout << sizeof(CBase3) << std::endl; // 16字节，可见子类的大小是本身成员变量的大小加上父类的大小
    CBase3 cb3();
    std::cout << sizeof(cb3.a)) << std::endl;
//  总结：

// 空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

// （一）类内部的成员变量：

// 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
// static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
// （二）类内部的成员函数：

// 普通函数：不占用内存。
// 虚函数：要占用4个以上字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。
// ————————————————
// 版权声明：本文为CSDN博主「YLEOY」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
// 原文链接：https://blog.csdn.net/leigelaile1/article/details/81982103
}
```

# 查看一个进行的栈内存和堆内存

