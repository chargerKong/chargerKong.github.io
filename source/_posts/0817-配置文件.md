---
title: 配置文件-cartographer
date: 2021-09-05 15:59:22
tags: cartographer
---

## 在launch文件中，通过配置

```
roslaunch xxxpkg xxx.launch name:=value
```

这个name是通过launch文件中

```
<arg name="bag_filename" default="">
```

来配置



使用map_server就可以直接发布map，发布出来



rosrun map_server



args = "yaml"文件



定位是来自于map->odom的变换



# lua文件的配置

三个部分：

- options:必须要有的，所有的变量参数都要存在，要是有一个不存在就会报错
- 需要引入map_build.lua
- 需要引入trajectory_builder

## Options

tracking_frame：需要选一个频率最高的frame，

published_frame: 设置到机器人最顶上的frame，可以保证map和他的连接

privide_odom_frame: 是否需要提供odom坐标系



一般有问题的就是

use_laser_num:如果用了topic的名字是不是remap了

- 若use_laser_num的值为0，则不用laser_scan
- =1。订阅scan topic
- =2。订阅scan_1,scan_2两种topic

num_point_clouds 表示使用点云数据:

- =0。不使用点云来建图

- =1。订阅points2
- =2。订阅points2_1，points2_2

## 举例

### 无odom的bag

假设现在有一个bag，他的TF tree为

![](Screenshot from 2021-08-17 16-23-28.png)

他最顶上的frame为footprint，在设置cartographer的时候，lua文件可以设置为

```
map_frame = "map",
tracking_frame = "imu_link",
published_frame = "footprint",
odom_frame = "odom",
provide_odom_frame = false,
publish_frame_projected_to_2d = false,
```

这里设置了published_frame为footprint，表示cartographer发布的指向的最后一个frame为footprint，这样可以让cartographer到机器人的tf可以连接到一起

现在其他参数不动，设置

```
provide_odom_frame = true,
```

![](Screenshot from 2021-08-17 16-38-26.png)

TF_tree增加了一个map->odom的坐标变换

### 有odom的bag

现在有一个bag的tf树为

![](Screenshot from 2021-08-17 16-41-31.png)

相比与之前的bag多了一个odom，此时需要调整lua文件的published_frame

```
  map_frame = "map",                        -- 地图坐标系的名字
  tracking_frame = "imu_link",              -- 将所有传感器数据转换到这个坐标系下
  published_frame = "odom",          	    -- tf: map -> odom
  odom_frame = "odom",                      -- 里程计的坐标系名字
  provide_odom_frame = false,  
```

启动cartographer，可以看见，map直接指向了原有的odom坐标系

![](Screenshot from 2021-08-17 16-44-21.png)

### 错误

如果published_frame定义错误，tf树连接不起来，通常情况下就会有类似如下错误

```
"odom" passed to lookupTransform argument source_frame does not exist.
```



## trajectory_build 参数

文件：trajectory_builder_2d.lua



min_z

max_z： 保留了【min_z,max_z】中的所有点云



missing_data_ray_length: 对于超出了最大距离的点，就改为这个变量指定的值。就是用于更新空白的区域，因为距离远，一般近的地方也都可以用，设1就行



位姿预测器

扫描匹配器



motion_filter: 为了 防止雷达数据向子图插入太多的数据，若两帧的数据太近，就不插入了



支持两种地图：

- tsdf
- 占用栅格地图



文件：trajectory_builder_3d.lua

两种体素滤波，根据远近，建立高低分辨率的地图。高分辨率匹配高分辨率的地图，低分辨率匹配低分辨率的地图



## pose_graph.lua 

这个文件需要调整的参数其实比较少，就前面五个和分支定界算法的角度，和回环的频率



  optimize_every_n_nodes = 90,-- 每隔多少个节点执行一次后端优化

如果设置称0，就是只跑前端，可以看看只跑前端是不是好的。



sampling_ratio = 0.3,  设置的越大，计算量越大



计算约束分为两个步骤

- 分支定界：粗匹配器
- ceres的精匹配器

当SLAM跑完了之后，就不需要实时性，因此最后还会再来一个迭代

  global_sampling_ratio = 0.003,

  log_residual_histograms = true,

  global_constraint_search_after_n_seconds = 10.,

这两个参数一起决定了我是否要进行回环检测



## 调参的方法

### [Low Latency](https://google-cartographer-ros.readthedocs.io/en/latest/tuning.html#low-latency)，如果需要提升实时性

减小optimize_every_n_nodes

减少子图的大小



如果前端需要提升实时性

- increase `voxel_filter_size`
- increase `submaps.resolution`
- for the adaptive voxel filter(s), decrease `.min_num_points`, `.max_range`, increase `.max_length`
- decrease `max_range` (especially if data is noisy)
- decrease `submaps.num_range_data`



# Exploiting the map generated by Cartographer ROS

主要写的是asset这个工具进行描述

