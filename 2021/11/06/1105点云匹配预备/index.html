<!DOCTYPE html>
<html lang="ch">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Kong Liangqian">
    
    <title>
        
            点云匹配预备-cartographer |
        
        大杂烩
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/wuwuwu.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chargerkong.github.io","root":"/","language":"ch"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/wuwuwu.jpg","favicon":"/images/wuwuwu.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                大杂烩
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">点云匹配预备-cartographer</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/wuwuwu.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Kong Liangqian</span>
                        
                            <span class="author-label">Lv6</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-11-06 18:38:29
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/cartographer/">cartographer</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>上节说到，在global_traject_builder 中会进行AddSensorData 加入转化为点云的雷达扫描数据</p>
<p>第一步即，扫描匹配，in GlobalTrajectoryBuilder类的AddSensorData中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行扫描匹配, 返回匹配后的结果</span></span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> LocalTrajectoryBuilder::MatchingResult&gt;</span><br><span class="line">    matching_result = local_trajectory_builder_-&gt;<span class="built_in">AddRangeData</span>(</span><br><span class="line">        sensor_id, timed_point_cloud_data);</span><br></pre></td></tr></table></figure>
<p>local<em>trajectory_builder</em> 在构造函数的时候即被赋予了初值。</p>
<p>可以为LocalTrajectoryBuilder2d 或者 LocalTrajectoryBuilder3d</p>
<p>我们先看LocalTrajectoryBuilder2d, 位于<code>cartograpger/mapping/internal/2d/local_trajectory_builder_2d.h</code></p>
<h1 id="点云数据结构"><a href="#点云数据结构" class="headerlink" title="点云数据结构"></a>点云数据结构</h1><p>在介绍匹配之前，我们首先强调一下cartographer中保存点云的数据结构</p>
<p>没有时间同步前的点云sensor::TimedPointCloudData</p>
<p><strong>每一块点云都有一个时间time，表示此点云最后一个点的时间</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间同步前的点云</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimedPointCloudData</span> &#123;</span></span><br><span class="line">  common::Time time;        <span class="comment">// 点云最后一个点的时间</span></span><br><span class="line">  Eigen::Vector3f origin;   <span class="comment">// 以tracking_frame_到雷达坐标系的坐标变换为原点</span></span><br><span class="line">  TimedPointCloud ranges;   <span class="comment">// 数据点的集合, 每个数据点包含xyz与time, time是负的</span></span><br><span class="line">  <span class="comment">// &#x27;intensities&#x27; has to be same size as &#x27;ranges&#x27;, or empty.</span></span><br><span class="line">  std::vector&lt;<span class="keyword">float</span>&gt; intensities; <span class="comment">// 空的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再看数据点<strong>TimedPointCloud</strong>，是一个保存了所有点的一个vector</p>
<p>using TimedPointCloud = std::vector\<TimedRangefinderPoint>;</p>
<p>每一个点，都有一个自己的时间，但是是负的，根据time_increment计算得到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stores 3D position of a point with its relative measurement time.</span></span><br><span class="line"><span class="comment">// See point_cloud.h for more details.</span></span><br><span class="line"><span class="comment">// 带时间戳的单个数据点的坐标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimedRangefinderPoint</span> &#123;</span></span><br><span class="line">  Eigen::Vector3f position;</span><br><span class="line">  <span class="keyword">float</span> time; <span class="comment">// 相对点云最后一个点的时间, 最后一个点的时间为0, 其他点的时间都为负的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="LocalTrajectoryBuilder2D头文件"><a href="#LocalTrajectoryBuilder2D头文件" class="headerlink" title="LocalTrajectoryBuilder2D头文件"></a>LocalTrajectoryBuilder2D头文件</h1><p>首先看一下头文件，为两个保存结果的结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalTrajectoryBuilder2D</span> &#123;</span>  </span><br><span class="line">  <span class="comment">// 将点云插入到地图后的result</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">InsertionResult</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">const</span> TrajectoryNode::Data&gt; constant_data;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;<span class="keyword">const</span> Submap2D&gt;&gt; insertion_submaps; <span class="comment">// 最多只有2个子图的指针</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 扫描匹配的result</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MatchingResult</span> &#123;</span></span><br><span class="line">    common::Time time;</span><br><span class="line">    transform::Rigid3d local_pose;</span><br><span class="line">    sensor::RangeData range_data_in_local; <span class="comment">// 经过扫描匹配之后位姿校准之后的雷达数据</span></span><br><span class="line">    <span class="comment">// &#x27;nullptr&#x27; if dropped by the motion filter.</span></span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">const</span> InsertionResult&gt; insertion_result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>看一下成员变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ActiveSubmaps2D active_submaps_; <span class="comment">// 只有两个子图的vector,当一个子图完成了就删掉， 然后新建一个</span></span><br><span class="line">MotionFilter motion_filter_; <span class="comment">//对运动进行过滤，如果运动的太近，或者运行距离太短就会被过滤掉</span></span><br><span class="line">scan_matching::RealTimeCorrelativeScanMatcher2D</span><br><span class="line">    real_time_correlative_scan_matcher_;</span><br><span class="line">scan_matching::CeresScanMatcher2D ceres_scan_matcher_;</span><br><span class="line">std::unique_ptr&lt;PoseExtrapolator&gt; extrapolator_; <span class="comment">//位姿估计器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_accumulated_ = <span class="number">0</span>;</span><br><span class="line">sensor::RangeData accumulated_range_data_;</span><br><span class="line"></span><br><span class="line">absl::optional&lt;std::chrono::steady_clock::time_point&gt; last_wall_time_;</span><br><span class="line">absl::optional&lt;<span class="keyword">double</span>&gt; last_thread_cpu_time_seconds_;</span><br><span class="line">absl::optional&lt;common::Time&gt; last_sensor_time_;</span><br><span class="line"></span><br><span class="line">RangeDataCollator range_data_collator_; <span class="comment">//雷达数据时间同步的一个类</span></span><br></pre></td></tr></table></figure>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构造函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in] options </span></span><br><span class="line"><span class="comment"> * @param[in] expected_range_sensor_ids 所有range类型的话题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LocalTrajectoryBuilder2D::<span class="built_in">LocalTrajectoryBuilder2D</span>(</span><br><span class="line">    <span class="keyword">const</span> proto::LocalTrajectoryBuilderOptions2D&amp; options,</span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; expected_range_sensor_ids)</span><br><span class="line">    : <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">active_submaps_</span>(options.<span class="built_in">submaps_options</span>()),</span><br><span class="line">      <span class="built_in">motion_filter_</span>(options_.<span class="built_in">motion_filter_options</span>()),</span><br><span class="line">      <span class="built_in">real_time_correlative_scan_matcher_</span>(</span><br><span class="line">          options_.<span class="built_in">real_time_correlative_scan_matcher_options</span>()),</span><br><span class="line">      <span class="built_in">ceres_scan_matcher_</span>(options_.<span class="built_in">ceres_scan_matcher_options</span>()),</span><br><span class="line">      <span class="built_in">range_data_collator_</span>(expected_range_sensor_ids) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数即对一些成员变量赋值</p>
<p>options对应的配置文件为trajectory_builder_2d.lua的所有参数</p>
<p>options.submaps_options() 可以获得这个lua文件中，submaps下大括号的参数配置</p>
<p>options_.motion_filter_options() 可以对应 motion_filter下的参数配置</p>
<p>options_.ceres_scan_matcher_options() 可以获得ceres_scan_matcher下的所有配置</p>
<p>options_.real_time_correlative_scan_matcher_options() 可以获得real_time_correlative_scan_matcher下的所有配置</p>
<p>下面是lua配置文件的整体结构</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">TRAJECTORY_BUILDER_2D = &#123;</span><br><span class="line">  use_imu_data = <span class="literal">true</span>,            <span class="comment">-- 是否使用imu数据</span></span><br><span class="line">  min_range = <span class="number">0.</span>,                 <span class="comment">-- 雷达数据的最远最近滤波, 保存中间值</span></span><br><span class="line">  max_range = <span class="number">30.</span>,</span><br><span class="line">  min_z = <span class="number">-0.8</span>,                   <span class="comment">-- 雷达数据的最高与最低的过滤, 保存中间值</span></span><br><span class="line">  max_z = <span class="number">2.</span>,</span><br><span class="line">  missing_data_ray_length = <span class="number">5.</span>,   <span class="comment">-- 超过最大距离范围的数据点用这个距离代替</span></span><br><span class="line">  num_accumulated_range_data = <span class="number">1</span>, <span class="comment">-- 几帧有效的点云数据进行一次扫描匹配</span></span><br><span class="line">  voxel_filter_size = <span class="number">0.025</span>,      <span class="comment">-- 体素滤波的立方体的边长</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">-- 使用固定的voxel滤波之后, 再使用自适应体素滤波器</span></span><br><span class="line">  <span class="comment">-- 体素滤波器 用于生成稀疏点云 以进行 扫描匹配</span></span><br><span class="line">  adaptive_voxel_filter = &#123;...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">-- 闭环检测的自适应体素滤波器, 用于生成稀疏点云 以进行 闭环检测</span></span><br><span class="line">  loop_closure_adaptive_voxel_filter = &#123;...</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 是否使用 real_time_correlative_scan_matcher 为ceres提供先验信息</span></span><br><span class="line">  <span class="comment">-- 计算复杂度高 , 但是很鲁棒 , 在odom或者imu不准时依然能达到很好的效果</span></span><br><span class="line">  use_online_correlative_scan_matching = <span class="literal">false</span>,</span><br><span class="line">  real_time_correlative_scan_matcher = &#123;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">-- ceres匹配的一些配置参数</span></span><br><span class="line">  ceres_scan_matcher = &#123;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 为了防止子图里插入太多数据, 在插入子图之前之前对数据进行过滤</span></span><br><span class="line">  motion_filter = &#123;</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line">  <span class="comment">-- TODO(schwoere,wohe): Remove this constant. This is only kept for ROS.</span></span><br><span class="line">  imu_gravity_time_constant = <span class="number">10.</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 位姿预测器</span></span><br><span class="line">  pose_extrapolator = &#123;</span><br><span class="line">            </span><br><span class="line">  <span class="comment">-- 子图相关的一些配置</span></span><br><span class="line">  submaps = &#123;...</span><br><span class="line">	&#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="AddRangeData-函数"><a href="#AddRangeData-函数" class="headerlink" title="AddRangeData 函数"></a>AddRangeData 函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理点云数据, 进行扫描匹配, 将点云写成地图</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in] sensor_id 点云数据对应的话题名称</span></span><br><span class="line"><span class="comment"> * @param[in] unsynchronized_data 传入的点云数据</span></span><br><span class="line"><span class="comment"> * @return std::unique_ptr&lt;LocalTrajectoryBuilder2D::MatchingResult&gt; 匹配后的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> std::unique_ptr&lt;LocalTrajectoryBuilder2D::MatchingResult&gt;</span><br><span class="line">LocalTrajectoryBuilder2D::<span class="built_in">AddRangeData</span>(</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; sensor_id,</span><br><span class="line">    <span class="keyword">const</span> sensor::TimedPointCloudData&amp; unsynchronized_data) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Step: 1 进行多个雷达点云数据的时间同步, 点云的坐标是相对于tracking_frame的</span></span><br><span class="line">  <span class="keyword">auto</span> synchronized_data =</span><br><span class="line">      range_data_collator_.<span class="built_in">AddRangeData</span>(sensor_id, unsynchronized_data);</span><br></pre></td></tr></table></figure>
<h2 id="点云时间同步"><a href="#点云时间同步" class="headerlink" title="点云时间同步"></a>点云时间同步</h2><p>第一步，将多个雷达信息的点云时间进行同步，并且返回同步后的数据，点云如何同步查看下一篇。</p>
<p>返回后的数据结构为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间同步后的点云</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimedPointCloudOriginData</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RangeMeasurement</span> &#123;</span></span><br><span class="line">    TimedRangefinderPoint point_time;   <span class="comment">// 带时间戳的单个数据点的坐标 xyz</span></span><br><span class="line">    <span class="keyword">float</span> intensity;                    <span class="comment">// 强度值</span></span><br><span class="line">    <span class="keyword">size_t</span> origin_index;                <span class="comment">// 属于第几个origins的点</span></span><br><span class="line">  &#125;;</span><br><span class="line">  common::Time time;                    <span class="comment">// 点云的时间</span></span><br><span class="line">  std::vector&lt;Eigen::Vector3f&gt; origins; <span class="comment">// 点云是由几个点云组成, 每个点云的原点</span></span><br><span class="line">  std::vector&lt;RangeMeasurement&gt; ranges; <span class="comment">// 数据点的集合</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，time 表示此点云最后一个点的时间</p>
<p>如果，没有使用imu的话，启动位姿估计器，位姿估计器后续再说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> common::Time&amp; time = synchronized_data.time;</span><br><span class="line"><span class="comment">// Initialize extrapolator now if we do not ever use an IMU.</span></span><br><span class="line"><span class="comment">// 如果不用imu, 就在雷达这初始化位姿推测器</span></span><br><span class="line"><span class="keyword">if</span> (!options_.<span class="built_in">use_imu_data</span>()) &#123;</span><br><span class="line">  <span class="built_in">InitializeExtrapolator</span>(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个for循环 利用位姿估计器，估计每一个点的位姿，放入range_data_poses</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; range : synchronized_data.ranges) &#123;</span><br><span class="line">  common::Time time_point = time + common::<span class="built_in">FromSeconds</span>(range.point_time.time);</span><br><span class="line">  <span class="comment">// 如果该时间比上次预测位姿的时间还要早,说明这个点的时间戳往回走了, 就报错</span></span><br><span class="line">  <span class="keyword">if</span> (time_point &lt; extrapolator_-&gt;<span class="built_in">GetLastExtrapolatedTime</span>()) &#123;</span><br><span class="line">    <span class="comment">// 一个循环只报一次错</span></span><br><span class="line">    <span class="keyword">if</span> (!warned) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(ERROR)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Timestamp of individual range data point jumps backwards from &quot;</span></span><br><span class="line">          &lt;&lt; extrapolator_-&gt;<span class="built_in">GetLastExtrapolatedTime</span>() &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; time_point;</span><br><span class="line">      warned = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    time_point = extrapolator_-&gt;<span class="built_in">GetLastExtrapolatedTime</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Step: 2 预测出 每个点的时间戳时刻, tracking frame 在 local slam 坐标系下的位姿</span></span><br><span class="line">  range_data_poses.<span class="built_in">push_back</span>(</span><br><span class="line">      extrapolator_-&gt;<span class="built_in">ExtrapolatePose</span>(time_point).cast&lt;<span class="keyword">float</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运动畸变"><a href="#运动畸变" class="headerlink" title="运动畸变"></a>运动畸变</h2><p>下面是运动畸变的去除：</p>
<p>运动畸变产生的原因，雷达转动一圈的过程中，始终已发出第一针的位置为坐标系，因此在运动的过程中测到的雷达距离会不准，比如墙体越来越近，那么画到了原来的坐标系上就会产生一条斜的墙面，见下图</p>
<p><img src="image-20211108003834642.png" alt=""></p>
<p><img src="1105点云匹配/image-20211108003834642.png" alt="image-20211108003834642"></p>
<p>那么只要我们得到每一个点所机器人对应的移动距离，（即我们用位姿估计器得到的值），用这个移动距离把测到的值映射到原来的坐标系中，就可以较为准确的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drop any returns below the minimum range and convert returns beyond the</span></span><br><span class="line"><span class="comment">// maximum range into misses.</span></span><br><span class="line"><span class="comment">// 对每个数据点进行处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; synchronized_data.ranges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  <span class="comment">// 获取在tracking frame 下点的坐标</span></span><br><span class="line">  <span class="keyword">const</span> sensor::TimedRangefinderPoint&amp; hit =</span><br><span class="line">      synchronized_data.ranges[i].point_time;</span><br><span class="line">  <span class="comment">// 将点云的origins坐标转到 local slam 坐标系下</span></span><br><span class="line">  <span class="keyword">const</span> Eigen::Vector3f origin_in_local =</span><br><span class="line">      range_data_poses[i] *</span><br><span class="line">      synchronized_data.origins.<span class="built_in">at</span>(synchronized_data.ranges[i].origin_index);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Step: 3 运动畸变的去除, 将相对于tracking_frame的hit坐标 转成 local坐标系下的坐标</span></span><br><span class="line">  sensor::RangefinderPoint hit_in_local =</span><br><span class="line">      range_data_poses[i] * sensor::<span class="built_in">ToRangefinderPoint</span>(hit); <span class="comment">//此函数返回点的位置</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算这个点的距离, 这里用的是去畸变之后的点的距离</span></span><br><span class="line">  <span class="keyword">const</span> Eigen::Vector3f delta = hit_in_local.position - origin_in_local;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span> range = delta.<span class="built_in">norm</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// param: min_range max_range</span></span><br><span class="line">  <span class="keyword">if</span> (range &gt;= options_.<span class="built_in">min_range</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (range &lt;= options_.<span class="built_in">max_range</span>()) &#123;</span><br><span class="line">      <span class="comment">// 在这里可以看到, returns里保存的是local slam下的去畸变之后的点的坐标</span></span><br><span class="line">      accumulated_range_data_.returns.<span class="built_in">push_back</span>(hit_in_local);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Step: 4 超过max_range时的处理: 用一个距离进行替代, 并放入misses里</span></span><br><span class="line">      hit_in_local.position =</span><br><span class="line">          origin_in_local +</span><br><span class="line">          <span class="comment">// param: missing_data_ray_length, 是个比例, 不是距离</span></span><br><span class="line">          options_.<span class="built_in">missing_data_ray_length</span>() / range * delta;</span><br><span class="line">      accumulated_range_data_.misses.<span class="built_in">push_back</span>(hit_in_local);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// end for</span></span><br></pre></td></tr></table></figure>
<p>关于accumulated<em>range_data</em>的数据结构，他保存的是最后的转到local slam坐标系下的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief local_slam_data中存储所有雷达点云的数据结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param origin  点云的原点在local坐标系下的坐标</span></span><br><span class="line"><span class="comment"> * @param returns 所有雷达数据点在local坐标系下的坐标, 记为returns, 也就是hit</span></span><br><span class="line"><span class="comment"> * @param misses  是在光线方向上未检测到返回的点(nan, inf等等)或超过最大配置距离的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RangeData</span> &#123;</span></span><br><span class="line">  Eigen::Vector3f origin;</span><br><span class="line">  PointCloud returns;</span><br><span class="line">  PointCloud misses; <span class="comment">// local坐标系下的坐标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="开始匹配"><a href="#开始匹配" class="headerlink" title="开始匹配"></a>开始匹配</h2><p>此时，我们就有了一帧有效的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一帧有效的数据了</span></span><br><span class="line">++num_accumulated_;</span><br></pre></td></tr></table></figure>
<p>当有效的数据达到配置文件设置的大小，则开始一次匹配，匹配前，获取机器人当前姿态，最后一个点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num_accumulated_ &gt;= options_.<span class="built_in">num_accumulated_range_data</span>()) &#123;</span><br><span class="line">    <span class="comment">// 计算2次有效点云数据的的时间差</span></span><br><span class="line">    <span class="keyword">const</span> common::Time current_sensor_time = synchronized_data.time;</span><br><span class="line">    absl::optional&lt;common::Duration&gt; sensor_duration;</span><br><span class="line">    <span class="keyword">if</span> (last_sensor_time_.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      sensor_duration = current_sensor_time - last_sensor_time_.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    last_sensor_time_ = current_sensor_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置变量</span></span><br><span class="line">    num_accumulated_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取机器人当前姿态</span></span><br><span class="line">    <span class="keyword">const</span> transform::Rigid3d gravity_alignment = transform::Rigid3d::<span class="built_in">Rotation</span>(</span><br><span class="line">        extrapolator_-&gt;<span class="built_in">EstimateGravityOrientation</span>(time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(gaschler): This assumes that &#x27;range_data_poses.back()&#x27; is at time</span></span><br><span class="line">    <span class="comment">// &#x27;time&#x27;.</span></span><br><span class="line">    <span class="comment">// 以最后一个点的时间戳估计出的坐标为这帧数据的原点</span></span><br><span class="line">    <span class="comment">// range_data_poses为保存着每一个时间点的位姿</span></span><br><span class="line">    accumulated_range_data_.origin = range_data_poses.<span class="built_in">back</span>().<span class="built_in">translation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AddAccumulatedRangeData</span>(</span><br><span class="line">        time,</span><br><span class="line">        <span class="comment">// 将点云变换到local原点处, 且姿态为0</span></span><br><span class="line">        <span class="built_in">TransformToGravityAlignedFrameAndFilter</span>(</span><br><span class="line">            gravity_alignment.cast&lt;<span class="keyword">float</span>&gt;() * range_data_poses.<span class="built_in">back</span>().<span class="built_in">inverse</span>(),</span><br><span class="line">            accumulated_range_data_),</span><br><span class="line">        gravity_alignment, sensor_duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/11/06/1106%E7%82%B9%E4%BA%91%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">点云时间同步-cartographer</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/11/05/1105%20cartographer%E5%B0%8F%E7%BB%93/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">cartographer-数据分发小结</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div id="gitalk-container"></div>
    <script 
            src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
    <script >

        function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
                __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
                Gitalk && new Gitalk({
                    clientID: '79f544d13d21b2fcc133',
                    clientSecret: 'e0a9aab7ed86532d17f8c9e15ed14d875f074d4f',
                    repo: 'hexo-site-comment',
                    owner: 'chargerKong',
                    admin: ['chargerKong'],
                    id: __gitalk__pathname,
                    language: 'ch'
                }).render('gitalk-container');

            } catch (e) {
                window.Gitalk = null;
            }
        }

        if ('false') {
            const loadGitalkTimeout = setTimeout(() => {
                loadGitalk();
                clearTimeout(loadGitalkTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
        }
    </script>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Kong Liangqian</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">点云数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LocalTrajectoryBuilder2D%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">LocalTrajectoryBuilder2D头文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AddRangeData-%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">AddRangeData 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E4%BA%91%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5"><span class="nav-number">4.1.</span> <span class="nav-text">点云时间同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E5%8A%A8%E7%95%B8%E5%8F%98"><span class="nav-number">4.2.</span> <span class="nav-text">运动畸变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E5%8C%B9%E9%85%8D"><span class="nav-number">4.3.</span> <span class="nav-text">开始匹配</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>
